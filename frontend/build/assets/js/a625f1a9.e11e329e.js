"use strict";(globalThis.webpackChunkphysical_ai_book_docs=globalThis.webpackChunkphysical_ai_book_docs||[]).push([[912],{267(n,e,a){a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>_,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module3/navigation","title":"Navigation and Path Planning","description":"Navigation and path planning form the foundation of mobile robot autonomy. In this section, we\'ll explore how to implement these capabilities using Isaac Sim and Isaac ROS components.","source":"@site/docs/module3/navigation.md","sourceDirName":"module3","slug":"/module3/navigation","permalink":"/Physical-AI-Book/docs/module3/navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module3/navigation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Perception Pipelines in Isaac Sim","permalink":"/Physical-AI-Book/docs/module3/perception"},"next":{"title":"Module 3 Projects","permalink":"/Physical-AI-Book/docs/module3/projects"}}');var o=a(4848),s=a(8453);const i={sidebar_position:4},r="Navigation and Path Planning",l={},c=[{value:"Introduction to Robot Navigation",id:"introduction-to-robot-navigation",level:2},{value:"Isaac ROS Navigation Components",id:"isaac-ros-navigation-components",level:2},{value:"Nav2 Integration with Isaac Sim",id:"nav2-integration-with-isaac-sim",level:3},{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"A* Path Planning Implementation",id:"a-path-planning-implementation",level:3},{value:"Dynamic Window Approach (DWA) Local Planner",id:"dynamic-window-approach-dwa-local-planner",level:3},{value:"Isaac Sim Navigation Pipeline",id:"isaac-sim-navigation-pipeline",level:2},{value:"Best Practices for Navigation",id:"best-practices-for-navigation",level:2},{value:"Exercise",id:"exercise",level:2},{value:"Summary",id:"summary",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"navigation-and-path-planning",children:"Navigation and Path Planning"})}),"\n",(0,o.jsx)(e.p,{children:"Navigation and path planning form the foundation of mobile robot autonomy. In this section, we'll explore how to implement these capabilities using Isaac Sim and Isaac ROS components."}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-robot-navigation",children:"Introduction to Robot Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Navigation involves:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Localization"}),": Determining the robot's position in the environment"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Mapping"}),": Creating a representation of the environment"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Planning"}),": Finding optimal routes from start to goal"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Motion Control"}),": Executing planned paths while avoiding obstacles"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"isaac-ros-navigation-components",children:"Isaac ROS Navigation Components"}),"\n",(0,o.jsx)(e.p,{children:"Isaac ROS provides optimized navigation components:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Isaac ROS Nav2 Bridge"}),"\n",(0,o.jsx)(e.li,{children:"Hardware-accelerated path planners"}),"\n",(0,o.jsx)(e.li,{children:"Optimized controllers"}),"\n",(0,o.jsx)(e.li,{children:"Perception-integrated navigation"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"nav2-integration-with-isaac-sim",children:"Nav2 Integration with Isaac Sim"}),"\n",(0,o.jsx)(e.p,{children:"Example launch file for Nav2 in Isaac Sim:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# launch/isaac_nav2.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, GroupAction\nfrom launch.conditions import IfCondition\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node, PushRosNamespace\nfrom launch_ros.substitutions import FindPackageShare\nimport os\n\ndef generate_launch_description():\n    # Launch configuration variables\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\n    params_file = LaunchConfiguration('params_file')\n    default_nav2_params = PathJoinSubstitution(\n        [FindPackageShare('isaac_nav2_examples'), 'params', 'nav2_params.yaml']\n    )\n\n    # Map file\n    map_yaml_file = LaunchConfiguration('map')\n    default_map = PathJoinSubstitution(\n        [FindPackageShare('isaac_nav2_examples'), 'maps', 'simple_map.yaml']\n    )\n\n    return LaunchDescription([\n        # Launch Arguments\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='true',\n            description='Use simulation (Isaac Sim) clock if true'\n        ),\n\n        DeclareLaunchArgument(\n            'params_file',\n            default_value=default_nav2_params,\n            description='Full path to the ROS2 parameters file to use for all launched nodes'\n        ),\n\n        DeclareLaunchArgument(\n            'map',\n            default_value=default_map,\n            description='Full path to map file to load'\n        ),\n\n        # Isaac Sim bridge for navigation\n        Node(\n            package='isaac_ros_bridges',\n            executable='isaac_ros_nav_bridge',\n            name='isaac_nav_bridge',\n            parameters=[{'use_sim_time': use_sim_time}],\n            remappings=[\n                ('/tf', 'tf'),\n                ('/tf_static', 'tf_static'),\n                ('/initialpose', 'initialpose'),\n                ('/goal_pose', 'goal_pose'),\n                ('/cmd_vel', 'cmd_vel'),\n                ('/odom', 'odom'),\n                ('/scan', 'scan'),\n                ('/map', 'map'),\n                ('/map_updates', 'map_updates'),\n            ]\n        ),\n\n        # Navigation stack\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                PathJoinSubstitution([\n                    FindPackageShare('nav2_bringup'),\n                    'launch',\n                    'navigation_launch.py'\n                ])\n            ]),\n            launch_arguments={\n                'use_sim_time': use_sim_time,\n                'params_file': params_file\n            }.items(),\n        ),\n\n        # AMCL for localization\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                PathJoinSubstitution([\n                    FindPackageShare('nav2_bringup'),\n                    'launch',\n                    'localization_launch.py'\n                ])\n            ]),\n            launch_arguments={\n                'use_sim_time': use_sim_time,\n                'map': map_yaml_file,\n                'params_file': params_file\n            }.items(),\n        )\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,o.jsx)(e.h3,{id:"a-path-planning-implementation",children:"A* Path Planning Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import OccupancyGrid, Path\nfrom geometry_msgs.msg import PoseStamped, Point\nfrom visualization_msgs.msg import Marker, MarkerArray\nimport numpy as np\nimport heapq\n\nclass AStarPlanner(Node):\n    def __init__(self):\n        super().__init__(\'astar_planner\')\n\n        # Subscriptions\n        self.map_sub = self.create_subscription(\n            OccupancyGrid, \'/map\', self.map_callback, 10\n        )\n        self.goal_sub = self.create_subscription(\n            PoseStamped, \'/goal_pose\', self.goal_callback, 10\n        )\n\n        # Publishers\n        self.path_pub = self.create_publisher(Path, \'/plan\', 10)\n        self.vis_pub = self.create_publisher(MarkerArray, \'/path_visualization\', 10)\n\n        # Map data\n        self.map_data = None\n        self.map_width = 0\n        self.map_height = 0\n        self.map_resolution = 0.0\n        self.map_origin = None\n\n        # Goal\n        self.goal = None\n\n        # Path planning parameters\n        self.inflation_radius = 0.5  # meters\n\n    def map_callback(self, msg):\n        """Process occupancy grid map."""\n        self.map_data = np.array(msg.data).reshape(msg.info.height, msg.info.width)\n        self.map_width = msg.info.width\n        self.map_height = msg.info.height\n        self.map_resolution = msg.info.resolution\n        self.map_origin = msg.info.origin\n\n    def goal_callback(self, msg):\n        """Process new goal pose."""\n        if self.map_data is not None:\n            # Convert goal coordinates to map indices\n            goal_x = msg.pose.position.x\n            goal_y = msg.pose.position.y\n\n            # Convert to map coordinates\n            map_x = int((goal_x - self.map_origin.position.x) / self.map_resolution)\n            map_y = int((goal_y - self.map_origin.position.y) / self.map_resolution)\n\n            # Check bounds\n            if 0 <= map_x < self.map_width and 0 <= map_y < self.map_height:\n                self.goal = (map_x, map_y)\n                self.get_logger().info(f\'New goal set: ({map_x}, {map_y})\')\n\n                # Plan path from current position\n                current_pos = self.get_current_position()\n                if current_pos:\n                    path = self.a_star_plan(current_pos, self.goal)\n                    if path:\n                        self.publish_path(path)\n                    else:\n                        self.get_logger().warn(\'No path found!\')\n\n    def get_current_position(self):\n        """Get current robot position from odometry (simplified)."""\n        # In practice, get from tf or odometry\n        # For this example, return a fixed start position\n        return (10, 10)  # Example start position\n\n    def a_star_plan(self, start, goal):\n        """A* path planning algorithm."""\n        if not self.is_valid(start[0], start[1]) or not self.is_valid(goal[0], goal[1]):\n            return None\n\n        # Directions: up, down, left, right, and diagonals\n        directions = [\n            (-1, 0), (1, 0), (0, -1), (0, 1),  # cardinal\n            (-1, -1), (-1, 1), (1, -1), (1, 1)  # diagonal\n        ]\n\n        # Heuristic function (Euclidean distance)\n        def heuristic(a, b):\n            return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\n\n        # Priority queue: (f_score, g_score, position)\n        open_set = [(heuristic(start, goal), 0, start)]\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: heuristic(start, goal)}\n\n        visited = set()\n\n        while open_set:\n            current_f, current_g, current = heapq.heappop(open_set)\n\n            if current == goal:\n                # Reconstruct path\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                path.reverse()\n                return path\n\n            visited.add(current)\n\n            for dx, dy in directions:\n                neighbor = (current[0] + dx, current[1] + dy)\n\n                # Check if neighbor is valid\n                if not self.is_valid(neighbor[0], neighbor[1]):\n                    continue\n\n                if neighbor in visited:\n                    continue\n\n                # Calculate tentative g_score\n                if abs(dx) + abs(dy) == 2:  # Diagonal move\n                    tentative_g = current_g + 1.414  # sqrt(2)\n                else:  # Cardinal move\n                    tentative_g = current_g + 1.0\n\n                if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g\n                    f_score[neighbor] = tentative_g + heuristic(neighbor, goal)\n\n                    heapq.heappush(open_set, (f_score[neighbor], g_score[neighbor], neighbor))\n\n        return None  # No path found\n\n    def is_valid(self, x, y):\n        """Check if position is valid (not occupied or outside map)."""\n        if x < 0 or x >= self.map_width or y < 0 or y >= self.map_height:\n            return False\n\n        # Check if cell is occupied (value > 50 in occupancy grid)\n        if self.map_data[y, x] > 50:  # Occupied\n            return False\n\n        return True\n\n    def publish_path(self, path):\n        """Publish the planned path."""\n        path_msg = Path()\n        path_msg.header.stamp = self.get_clock().now().to_msg()\n        path_msg.header.frame_id = \'map\'  # Assuming map frame\n\n        # Convert grid coordinates to world coordinates\n        for x, y in path:\n            pose = PoseStamped()\n            pose.header.stamp = self.get_clock().now().to_msg()\n            pose.header.frame_id = \'map\'\n\n            # Convert grid to world coordinates\n            pose.pose.position.x = self.map_origin.position.x + x * self.map_resolution\n            pose.pose.position.y = self.map_origin.position.y + y * self.map_resolution\n            pose.pose.position.z = self.map_origin.position.z\n\n            # Set orientation to face the next point (simplified)\n            if path.index((x, y)) < len(path) - 1:\n                next_x, next_y = path[path.index((x, y)) + 1]\n                angle = np.arctan2(next_y - y, next_x - x)\n\n                from tf_transformations import quaternion_from_euler\n                quat = quaternion_from_euler(0, 0, angle)\n                pose.pose.orientation.x = quat[0]\n                pose.pose.orientation.y = quat[1]\n                pose.pose.orientation.z = quat[2]\n                pose.pose.orientation.w = quat[3]\n\n            path_msg.poses.append(pose)\n\n        self.path_pub.publish(path_msg)\n        self.get_logger().info(f\'Published path with {len(path)} waypoints\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    planner = AStarPlanner()\n\n    try:\n        rclpy.spin(planner)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        planner.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"dynamic-window-approach-dwa-local-planner",children:"Dynamic Window Approach (DWA) Local Planner"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist, PoseWithCovarianceStamped, Point\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import Path, Odometry\nfrom visualization_msgs.msg import Marker\nimport numpy as np\n\nclass DWALocalPlanner(Node):\n    def __init__(self):\n        super().__init__(\'dwa_local_planner\')\n\n        # Subscriptions\n        self.odom_sub = self.create_subscription(\n            Odometry, \'/odom\', self.odom_callback, 10\n        )\n        self.laser_sub = self.create_subscription(\n            LaserScan, \'/scan\', self.laser_callback, 10\n        )\n        self.global_path_sub = self.create_subscription(\n            Path, \'/plan\', self.global_path_callback, 10\n        )\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        self.local_plan_pub = self.create_publisher(Path, \'/local_plan\', 10)\n        self.viz_pub = self.create_publisher(Marker, \'/dwa_trajectory\', 10)\n\n        # Robot state\n        self.current_pose = None\n        self.current_twist = None\n        self.laser_data = None\n        self.global_path = None\n\n        # DWA parameters\n        self.max_speed = 0.5  # m/s\n        self.min_speed = 0.0  # m/s\n        self.max_yawrate = 1.0  # rad/s\n        self.max_dyawrate = 10.0  # rad/s/s\n        self.v_reso = 0.05  # m/s\n        self.yawrate_reso = 0.1  # rad/s\n        self.dt = 0.1  # s\n        self.predict_time = 1.5  # s\n        self.to_goal_cost_gain = 1.0\n        self.speed_cost_gain = 1.0\n        self.obstacle_cost_gain = 1.0\n        self.robot_radius = 0.3  # m\n\n        # Control timer\n        self.control_timer = self.create_timer(0.1, self.control_callback)\n\n    def odom_callback(self, msg):\n        """Update robot state from odometry."""\n        self.current_pose = msg.pose.pose\n        self.current_twist = msg.twist.twist\n\n    def laser_callback(self, msg):\n        """Update laser scan data."""\n        self.laser_data = msg\n\n    def global_path_callback(self, msg):\n        """Update global path."""\n        self.global_path = msg.poses\n\n    def control_callback(self):\n        """Main control loop."""\n        if self.current_pose is None or self.global_path is None:\n            return\n\n        # Get current goal from global path\n        goal = self.get_next_waypoint()\n        if goal is None:\n            # Stop if no more waypoints\n            cmd_vel = Twist()\n            self.cmd_vel_pub.publish(cmd_vel)\n            return\n\n        # Run DWA\n        cmd_vel = self.dwa_control(goal)\n        self.cmd_vel_pub.publish(cmd_vel)\n\n        # Visualize local trajectory\n        self.visualize_trajectory(cmd_vel)\n\n    def get_next_waypoint(self):\n        """Get the next waypoint from the global path."""\n        if not self.global_path:\n            return None\n\n        # Find closest point on path\n        current_pos = np.array([self.current_pose.position.x, self.current_pose.position.y])\n\n        closest_dist = float(\'inf\')\n        closest_idx = 0\n\n        for i, pose_stamped in enumerate(self.global_path):\n            pos = np.array([pose_stamped.pose.position.x, pose_stamped.pose.position.y])\n            dist = np.linalg.norm(current_pos - pos)\n            if dist < closest_dist:\n                closest_dist = dist\n                closest_idx = i\n\n        # Return a point ahead in the path\n        lookahead_idx = min(closest_idx + 5, len(self.global_path) - 1)\n        goal_pos = self.global_path[lookahead_idx].pose.position\n        return np.array([goal_pos.x, goal_pos.y])\n\n    def dwa_control(self, goal):\n        """Dynamic Window Approach for local planning."""\n        # Current state\n        x = self.current_pose.position.x\n        y = self.current_pose.position.y\n        theta = self.get_yaw_from_quaternion(self.current_pose.orientation)\n        v = self.current_twist.linear.x\n        omega = self.current_twist.angular.z\n\n        # Calculate dynamic window\n        vs = [self.min_speed, self.max_speed,\n              -self.max_yawrate, self.max_yawrate]\n        vd = [v - self.dt * 0.5, v + self.dt * 0.5,\n              omega - self.dt * self.max_dyawrate, omega + self.dt * self.max_dyawrate]\n\n        # Limit window to feasible velocities\n        dw = [max(vs[0], vd[0]), min(vs[1], vd[1]),\n              max(vs[2], vd[2]), min(vs[3], vd[3])]\n\n        # Evaluate trajectories\n        best_traj = None\n        best_score = float(\'-inf\')\n\n        v_samples = np.arange(dw[0], dw[1], self.v_reso)\n        omega_samples = np.arange(dw[2], dw[3], self.yawrate_reso)\n\n        for v_sample in v_samples:\n            for omega_sample in omega_samples:\n                traj = self.predict_trajectory(x, y, theta, v_sample, omega_sample)\n\n                # Calculate costs\n                to_goal_cost = self.calc_to_goal_cost(traj, goal)\n                speed_cost = self.calc_speed_cost(traj)\n                obs_cost = self.calc_obstacle_cost(traj)\n\n                # Combined score (lower is better, so negate for maximization)\n                score = (self.to_goal_cost_gain * to_goal_cost +\n                         self.speed_cost_gain * speed_cost +\n                         self.obstacle_cost_gain * obs_cost)\n\n                if score > best_score:\n                    best_score = score\n                    best_traj = (v_sample, omega_sample)\n\n        # Create command\n        cmd_vel = Twist()\n        if best_traj:\n            cmd_vel.linear.x = best_traj[0]\n            cmd_vel.angular.z = best_traj[1]\n        else:\n            cmd_vel.linear.x = 0.0\n            cmd_vel.angular.z = 0.0\n\n        return cmd_vel\n\n    def predict_trajectory(self, x, y, theta, v, omega):\n        """Predict trajectory for given velocities."""\n        traj = []\n        time = 0\n        while time <= self.predict_time:\n            x += v * np.cos(theta) * self.dt\n            y += v * np.sin(theta) * self.dt\n            theta += omega * self.dt\n            traj.append([x, y])\n            time += self.dt\n        return np.array(traj)\n\n    def calc_to_goal_cost(self, traj, goal):\n        """Calculate cost to goal."""\n        if len(traj) == 0:\n            return float(\'inf\')\n\n        dx = goal[0] - traj[-1][0]\n        dy = goal[1] - traj[-1][1]\n        error = np.sqrt(dx**2 + dy**2)\n        return error\n\n    def calc_speed_cost(self, traj):\n        """Calculate cost based on speed."""\n        if len(traj) == 0:\n            return float(\'inf\')\n\n        v = np.sqrt((traj[-1][0] - traj[0][0])**2 + (traj[-1][1] - traj[0][1])**2) / self.predict_time\n        return abs(self.max_speed - v)\n\n    def calc_obstacle_cost(self, traj):\n        """Calculate cost based on obstacle proximity."""\n        if self.laser_data is None or len(traj) == 0:\n            return float(\'inf\')\n\n        min_dist = float(\'inf\')\n        for point in traj:\n            # Convert trajectory point to laser frame (simplified)\n            # In practice, use tf to transform coordinates\n            for i, range_val in enumerate(self.laser_data.ranges):\n                if not np.isfinite(range_val):\n                    continue\n\n                angle = self.laser_data.angle_min + i * self.laser_data.angle_increment\n                obs_x = point[0] + range_val * np.cos(angle)\n                obs_y = point[1] + range_val * np.sin(angle)\n\n                dist = np.sqrt((obs_x - point[0])**2 + (obs_y - point[1])**2)\n                min_dist = min(min_dist, dist)\n\n        if min_dist <= self.robot_radius:\n            return float(\'inf\')\n        else:\n            return 1.0 / min_dist\n\n    def get_yaw_from_quaternion(self, quaternion):\n        """Extract yaw from quaternion."""\n        import math\n        siny_cosp = 2 * (quaternion.w * quaternion.z + quaternion.x * quaternion.y)\n        cosy_cosp = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z)\n        return math.atan2(siny_cosp, cosy_cosp)\n\n    def visualize_trajectory(self, cmd_vel):\n        """Visualize the planned trajectory."""\n        marker = Marker()\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.header.frame_id = \'map\'\n        marker.ns = \'dwa_trajectory\'\n        marker.id = 0\n        marker.type = Marker.ARROW\n        marker.action = Marker.ADD\n\n        # Set start point (current position)\n        marker.points = []\n        start_point = Point()\n        start_point.x = self.current_pose.position.x\n        start_point.y = self.current_pose.position.y\n        start_point.z = 0.0\n        marker.points.append(start_point)\n\n        # Set end point (predicted position)\n        end_point = Point()\n        end_point.x = self.current_pose.position.x + cmd_vel.linear.x * 0.5\n        end_point.y = self.current_pose.position.y + cmd_vel.linear.y * 0.5\n        end_point.z = 0.0\n        marker.points.append(end_point)\n\n        marker.scale.x = 0.1  # shaft diameter\n        marker.scale.y = 0.2  # head diameter\n        marker.color.a = 1.0\n        marker.color.r = 1.0\n        marker.color.g = 0.0\n        marker.color.b = 0.0\n\n        self.viz_pub.publish(marker)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    planner = DWALocalPlanner()\n\n    try:\n        rclpy.spin(planner)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        planner.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(e.h2,{id:"isaac-sim-navigation-pipeline",children:"Isaac Sim Navigation Pipeline"}),"\n",(0,o.jsx)(e.p,{children:"Creating an integrated navigation system:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom nav_msgs.msg import Odometry, Path\nfrom sensor_msgs.msg import LaserScan, Image\nfrom visualization_msgs.msg import MarkerArray\nimport numpy as np\n\nclass IsaacNavigationSystem(Node):\n    def __init__(self):\n        super().__init__('isaac_navigation_system')\n\n        # Subscriptions\n        self.odom_sub = self.create_subscription(\n            Odometry, '/odom', self.odom_callback, 10\n        )\n        self.laser_sub = self.create_subscription(\n            LaserScan, '/scan', self.laser_callback, 10\n        )\n        self.camera_sub = self.create_subscription(\n            Image, '/camera/rgb', self.camera_callback, 10\n        )\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.goal_pub = self.create_publisher(PoseStamped, '/goal_pose', 10)\n        self.path_pub = self.create_publisher(Path, '/plan', 10)\n\n        # Navigation state\n        self.current_pose = None\n        self.current_velocity = None\n        self.laser_data = None\n        self.camera_data = None\n\n        # Navigation goals queue\n        self.goals = []\n        self.current_goal_index = 0\n\n        # Navigation state machine\n        self.state = 'WAITING'  # WAITING, PLANNING, EXECUTING, RECOVERY\n\n        # Timers\n        self.nav_timer = self.create_timer(0.1, self.navigation_loop)\n\n    def odom_callback(self, msg):\n        \"\"\"Update current pose and velocity.\"\"\"\n        self.current_pose = msg.pose.pose\n        self.current_velocity = msg.twist.twist\n\n    def laser_callback(self, msg):\n        \"\"\"Update laser scan data.\"\"\"\n        self.laser_data = msg\n\n    def camera_callback(self, msg):\n        \"\"\"Update camera data for visual navigation.\"\"\"\n        self.camera_data = msg\n\n    def add_goal(self, x, y, theta=0.0):\n        \"\"\"Add a navigation goal to the queue.\"\"\"\n        goal = PoseStamped()\n        goal.header.frame_id = 'map'\n        goal.pose.position.x = x\n        goal.pose.position.y = y\n        goal.pose.position.z = 0.0\n\n        # Convert theta to quaternion\n        from tf_transformations import quaternion_from_euler\n        quat = quaternion_from_euler(0, 0, theta)\n        goal.pose.orientation.x = quat[0]\n        goal.pose.orientation.y = quat[1]\n        goal.pose.orientation.z = quat[2]\n        goal.pose.orientation.w = quat[3]\n\n        self.goals.append(goal)\n        self.get_logger().info(f'Added goal: ({x}, {y}, {theta})')\n\n    def navigation_loop(self):\n        \"\"\"Main navigation state machine.\"\"\"\n        if self.current_pose is None:\n            return\n\n        if self.state == 'WAITING':\n            if self.goals and self.current_goal_index < len(self.goals):\n                self.state = 'PLANNING'\n                self.get_logger().info('Switching to PLANNING state')\n\n        elif self.state == 'PLANNING':\n            # Plan path to current goal\n            goal = self.goals[self.current_goal_index]\n            success = self.plan_path_to_goal(goal)\n\n            if success:\n                self.state = 'EXECUTING'\n                self.get_logger().info('Switching to EXECUTING state')\n            else:\n                self.state = 'RECOVERY'\n                self.get_logger().warn('Planning failed, switching to RECOVERY')\n\n        elif self.state == 'EXECUTING':\n            # Execute planned path\n            goal_reached = self.execute_path()\n\n            if goal_reached:\n                self.current_goal_index += 1\n                if self.current_goal_index >= len(self.goals):\n                    self.get_logger().info('All goals completed!')\n                    self.state = 'WAITING'\n                    self.stop_robot()\n                else:\n                    self.state = 'PLANNING'\n            else:\n                # Check for obstacles or other issues\n                if self.detect_obstacles():\n                    self.state = 'RECOVERY'\n                    self.get_logger().info('Obstacle detected, switching to RECOVERY')\n\n        elif self.state == 'RECOVERY':\n            # Perform recovery behaviors\n            recovered = self.perform_recovery()\n\n            if recovered:\n                self.state = 'PLANNING'\n                self.get_logger().info('Recovery successful, returning to PLANNING')\n            else:\n                # Still in recovery, continue\n                pass\n\n    def plan_path_to_goal(self, goal):\n        \"\"\"Plan path to the given goal.\"\"\"\n        # In Isaac ROS, this would call the global planner\n        # For now, we'll publish a simple path command\n        self.get_logger().info(f'Planning to goal: ({goal.pose.position.x}, {goal.pose.position.y})')\n\n        # Publish goal for Nav2\n        goal_msg = PoseStamped()\n        goal_msg.header.stamp = self.get_clock().now().to_msg()\n        goal_msg.header.frame_id = 'map'\n        goal_msg.pose = goal.pose\n\n        self.goal_pub.publish(goal_msg)\n        return True\n\n    def execute_path(self):\n        \"\"\"Execute the planned path.\"\"\"\n        # In Isaac ROS, this would use the local planner and controller\n        # For now, we'll implement a simple proportional controller\n\n        if not self.goals or self.current_goal_index >= len(self.goals):\n            return True\n\n        goal = self.goals[self.current_goal_index].pose\n        current_pos = self.current_pose.position\n\n        # Calculate distance to goal\n        dist_to_goal = np.sqrt(\n            (goal.position.x - current_pos.x)**2 +\n            (goal.position.y - current_pos.y)**2\n        )\n\n        # Check if goal is reached\n        if dist_to_goal < 0.2:  # 20 cm tolerance\n            self.get_logger().info('Goal reached!')\n            return True\n\n        # Simple proportional controller\n        cmd_vel = Twist()\n        cmd_vel.linear.x = min(0.3, max(0.0, dist_to_goal * 0.5))  # Proportional to distance\n\n        # Calculate heading to goal\n        angle_to_goal = np.arctan2(\n            goal.position.y - current_pos.y,\n            goal.position.x - current_pos.x\n        )\n\n        # Current robot orientation\n        from tf_transformations import euler_from_quaternion\n        (_, _, current_yaw) = euler_from_quaternion([\n            self.current_pose.orientation.x,\n            self.current_pose.orientation.y,\n            self.current_pose.orientation.z,\n            self.current_pose.orientation.w\n        ])\n\n        # Angle difference\n        angle_diff = angle_to_goal - current_yaw\n        while angle_diff > np.pi:\n            angle_diff -= 2 * np.pi\n        while angle_diff < -np.pi:\n            angle_diff += 2 * np.pi\n\n        cmd_vel.angular.z = max(-0.5, min(0.5, angle_diff * 2.0))  # Proportional to angle error\n\n        self.cmd_vel_pub.publish(cmd_vel)\n        return False\n\n    def detect_obstacles(self):\n        \"\"\"Detect obstacles using laser data.\"\"\"\n        if self.laser_data is None:\n            return False\n\n        # Check for obstacles in front of robot (simplified)\n        front_range = len(self.laser_data.ranges) // 2\n        front_left = front_range - 10\n        front_right = front_range + 10\n\n        min_dist = float('inf')\n        for i in range(front_left, front_right + 1):\n            if i < len(self.laser_data.ranges):\n                dist = self.laser_data.ranges[i]\n                if np.isfinite(dist):\n                    min_dist = min(min_dist, dist)\n\n        return min_dist < 0.5  # Obstacle within 50 cm\n\n    def perform_recovery(self):\n        \"\"\"Perform recovery behaviors.\"\"\"\n        # Simple recovery: backup and turn\n        cmd_vel = Twist()\n        cmd_vel.linear.x = -0.2  # Back up\n        cmd_vel.angular.z = 0.5  # Turn\n        self.cmd_vel_pub.publish(cmd_vel)\n\n        # Recovery after 2 seconds\n        import time\n        time.sleep(2.0)\n        self.stop_robot()\n\n        return True  # Recovery successful\n\n    def stop_robot(self):\n        \"\"\"Stop the robot.\"\"\"\n        cmd_vel = Twist()\n        cmd_vel.linear.x = 0.0\n        cmd_vel.angular.z = 0.0\n        self.cmd_vel_pub.publish(cmd_vel)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    nav_system = IsaacNavigationSystem()\n\n    # Add some example goals\n    nav_system.add_goal(5.0, 0.0)\n    nav_system.add_goal(5.0, 3.0)\n    nav_system.add_goal(0.0, 3.0)\n    nav_system.add_goal(0.0, 0.0)  # Return to start\n\n    try:\n        rclpy.spin(nav_system)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        nav_system.stop_robot()\n        nav_system.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(e.h2,{id:"best-practices-for-navigation",children:"Best Practices for Navigation"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Safe Speed Control"}),": Adjust speeds based on sensor reliability"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Robust Localization"}),": Use multiple sensors for reliable positioning"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic Replanning"}),": Adapt plans when obstacles are detected"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Behaviors"}),": Implement fallback strategies for failures"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Simulation Validation"}),": Test extensively in simulation before real deployment"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"exercise",children:"Exercise"}),"\n",(0,o.jsx)(e.p,{children:"Create a complete navigation system that:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Implements both global and local planning"}),"\n",(0,o.jsx)(e.li,{children:"Uses Isaac Sim sensors for obstacle detection"}),"\n",(0,o.jsx)(e.li,{children:"Handles dynamic obstacles"}),"\n",(0,o.jsx)(e.li,{children:"Includes recovery behaviors"}),"\n",(0,o.jsx)(e.li,{children:"Integrates with Isaac ROS navigation stack"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"In this section, you learned:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"How to implement path planning algorithms like A*"}),"\n",(0,o.jsx)(e.li,{children:"How to create local planners using DWA"}),"\n",(0,o.jsx)(e.li,{children:"How to build complete navigation systems"}),"\n",(0,o.jsx)(e.li,{children:"How to integrate with Isaac ROS navigation components"}),"\n",(0,o.jsx)(e.li,{children:"Best practices for robust navigation"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"In the next section, we'll explore projects that combine all navigation concepts."})]})}function _(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},8453(n,e,a){a.d(e,{R:()=>i,x:()=>r});var t=a(6540);const o={},s=t.createContext(o);function i(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);