"use strict";(globalThis.webpackChunkphysical_ai_book_docs=globalThis.webpackChunkphysical_ai_book_docs||[]).push([[112],{6997(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"module1/topics","title":"ROS 2 Topics and Messages","description":"Topics are named buses over which nodes exchange messages. Understanding topics is crucial for creating communication between different parts of your robotic system.","source":"@site/docs/module1/topics.md","sourceDirName":"module1","slug":"/module1/topics","permalink":"/docs/module1/topics","draft":false,"unlisted":false,"editUrl":"https://github.com/HM700/Physical_AI_Book/edit/master/frontend/docs/module1/topics.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Nodes","permalink":"/docs/module1/nodes"},"next":{"title":"Module 1 Projects","permalink":"/docs/module1/projects"}}');var r=n(4848),t=n(8453);const l={sidebar_position:4},o="ROS 2 Topics and Messages",c={},a=[{value:"Understanding Topics",id:"understanding-topics",level:2},{value:"Creating Custom Messages",id:"creating-custom-messages",level:2},{value:"Publisher Example",id:"publisher-example",level:2},{value:"Subscriber Example",id:"subscriber-example",level:2},{value:"Quality of Service (QoS) Settings",id:"quality-of-service-qos-settings",level:2},{value:"Topic Tools",id:"topic-tools",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Exercise",id:"exercise",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"ros-2-topics-and-messages",children:"ROS 2 Topics and Messages"})}),"\n",(0,r.jsx)(s.p,{children:"Topics are named buses over which nodes exchange messages. Understanding topics is crucial for creating communication between different parts of your robotic system."}),"\n",(0,r.jsx)(s.h2,{id:"understanding-topics",children:"Understanding Topics"}),"\n",(0,r.jsx)(s.p,{children:"Topics in ROS 2 implement a publish-subscribe communication pattern. Publishers send messages to a topic, and subscribers receive messages from a topic. This decouples the nodes that produce data from the nodes that consume data."}),"\n",(0,r.jsx)(s.h2,{id:"creating-custom-messages",children:"Creating Custom Messages"}),"\n",(0,r.jsxs)(s.p,{children:["While ROS 2 provides many standard message types, you'll often need to create custom messages. Create a file called ",(0,r.jsx)(s.code,{children:"NumArray.msg"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"int64[] data\nstring description\nuint32 count\n"})}),"\n",(0,r.jsxs)(s.p,{children:["To use custom messages, you need to create a package with a ",(0,r.jsx)(s.code,{children:"msg"})," directory and proper CMakeLists.txt configuration."]}),"\n",(0,r.jsx)(s.h2,{id:"publisher-example",children:"Publisher Example"}),"\n",(0,r.jsx)(s.p,{children:"Here's a more complex publisher example:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Int32\nfrom geometry_msgs.msg import Twist\n\nclass ComplexPublisher(Node):\n    def __init__(self):\n        super().__init__('complex_publisher')\n\n        # Multiple publishers\n        self.chatter_pub = self.create_publisher(String, 'chatter', 10)\n        self.number_pub = self.create_publisher(Int32, 'numbers', 10)\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\n\n        # Timer for periodic publishing\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n        self.counter = 0\n\n    def timer_callback(self):\n        # Publish string message\n        string_msg = String()\n        string_msg.data = f'Complex message #{self.counter}'\n        self.chatter_pub.publish(string_msg)\n\n        # Publish number message\n        number_msg = Int32()\n        number_msg.data = self.counter\n        self.number_pub.publish(number_msg)\n\n        # Publish velocity command\n        twist_msg = Twist()\n        twist_msg.linear.x = float(self.counter % 10) * 0.1  # Forward velocity\n        twist_msg.angular.z = float(self.counter % 4) * 0.5  # Angular velocity\n        self.cmd_vel_pub.publish(twist_msg)\n\n        self.get_logger().info(f'Published messages #{self.counter}')\n        self.counter += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    publisher = ComplexPublisher()\n\n    try:\n        rclpy.spin(publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(s.h2,{id:"subscriber-example",children:"Subscriber Example"}),"\n",(0,r.jsx)(s.p,{children:"Here's a subscriber that handles multiple topic types:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Int32\nfrom geometry_msgs.msg import Twist\nimport json\n\nclass ComplexSubscriber(Node):\n    def __init__(self):\n        super().__init__('complex_subscriber')\n\n        # Multiple subscriptions\n        self.string_sub = self.create_subscription(\n            String,\n            'chatter',\n            self.string_callback,\n            10\n        )\n\n        self.number_sub = self.create_subscription(\n            Int32,\n            'numbers',\n            self.number_callback,\n            10\n        )\n\n        self.cmd_vel_sub = self.create_subscription(\n            Twist,\n            'cmd_vel',\n            self.cmd_vel_callback,\n            10\n        )\n\n        # Store recent messages\n        self.recent_messages = []\n\n    def string_callback(self, msg):\n        self.get_logger().info(f'Received string: \"{msg.data}\"')\n        self.add_to_recent('string', msg.data)\n\n    def number_callback(self, msg):\n        self.get_logger().info(f'Received number: {msg.data}')\n        self.add_to_recent('number', msg.data)\n\n    def cmd_vel_callback(self, msg):\n        self.get_logger().info(\n            f'Received velocity: linear.x={msg.linear.x}, angular.z={msg.angular.z}'\n        )\n        velocity_data = {\n            'linear_x': msg.linear.x,\n            'angular_z': msg.angular.z\n        }\n        self.add_to_recent('velocity', velocity_data)\n\n    def add_to_recent(self, msg_type, content):\n        self.recent_messages.append({\n            'type': msg_type,\n            'content': content,\n            'timestamp': self.get_clock().now().seconds_nanoseconds()\n        })\n        # Keep only the last 10 messages\n        if len(self.recent_messages) > 10:\n            self.recent_messages.pop(0)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    subscriber = ComplexSubscriber()\n\n    try:\n        rclpy.spin(subscriber)\n    except KeyboardInterrupt:\n        # Print recent messages before exiting\n        print(\"\\nRecent messages:\")\n        for msg in subscriber.recent_messages:\n            print(f\"  {msg['type']}: {msg['content']}\")\n    finally:\n        subscriber.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(s.h2,{id:"quality-of-service-qos-settings",children:"Quality of Service (QoS) Settings"}),"\n",(0,r.jsx)(s.p,{children:"QoS settings allow you to control how messages are delivered:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\n\nclass QoSPublisher(Node):\n    def __init__(self):\n        super().__init__('qos_publisher')\n\n        # Create a QoS profile with specific settings\n        qos_profile = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,  # Ensure delivery\n            durability=DurabilityPolicy.VOLATILE,    # Don't keep old messages\n        )\n\n        self.publisher = self.create_publisher(String, 'qos_chatter', qos_profile)\n        self.timer = self.create_timer(1.0, self.timer_callback)\n        self.counter = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'QoS message #{self.counter}'\n        self.publisher.publish(msg)\n        self.counter += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = QoSPublisher()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(s.h2,{id:"topic-tools",children:"Topic Tools"}),"\n",(0,r.jsx)(s.p,{children:"ROS 2 provides command-line tools for inspecting topics:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"# List all topics\nros2 topic list\n\n# Show information about a specific topic\nros2 topic info /chatter\n\n# Echo messages from a topic\nros2 topic echo /chatter std_msgs/msg/String\n\n# Publish a message to a topic from command line\nros2 topic pub /chatter std_msgs/msg/String \"data: 'Hello from command line'\"\n"})}),"\n",(0,r.jsx)(s.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Topic Naming"}),": Use descriptive, lowercase names with underscores"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Message Types"}),": Choose appropriate message types for your data"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"QoS Settings"}),": Match QoS settings between publishers and subscribers"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Message Size"}),": Be mindful of message size for network performance"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Rate Limiting"}),": Avoid publishing too frequently without necessity"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"exercise",children:"Exercise"}),"\n",(0,r.jsx)(s.p,{children:"Create a system with:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"A publisher that publishes sensor readings (temperature, humidity, pressure)"}),"\n",(0,r.jsx)(s.li,{children:"A subscriber that receives these readings and calculates derived values"}),"\n",(0,r.jsx)(s.li,{children:"A third node that subscribes to the derived values and logs them to a file"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"This exercise will help you practice creating a multi-node system with custom data flows."}),"\n",(0,r.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(s.p,{children:"In this section, you learned:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"How to create publishers and subscribers for multiple topics"}),"\n",(0,r.jsx)(s.li,{children:"How to use Quality of Service settings"}),"\n",(0,r.jsx)(s.li,{children:"How to work with different message types"}),"\n",(0,r.jsx)(s.li,{children:"Best practices for topic design"}),"\n",(0,r.jsx)(s.li,{children:"Available command-line tools for debugging"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"In the next section, we'll explore services and actions for request-response communication patterns."})]})}function m(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,s,n){n.d(s,{R:()=>l,x:()=>o});var i=n(6540);const r={},t=i.createContext(r);function l(e){const s=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);