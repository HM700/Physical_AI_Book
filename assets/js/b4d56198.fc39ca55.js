"use strict";(globalThis.webpackChunkphysical_ai_book_docs=globalThis.webpackChunkphysical_ai_book_docs||[]).push([[960],{8453(n,e,i){i.d(e,{R:()=>a,x:()=>t});var o=i(6540);const r={},l=o.createContext(r);function a(n){const e=o.useContext(l);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),o.createElement(l.Provider,{value:e},n.children)}},8573(n,e,i){i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>t,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module2/gazebo","title":"Gazebo Simulation Environment","description":"Gazebo is a 3D dynamic simulator that supports accurate simulation of robots in complex indoor and outdoor environments. It\'s widely used in robotics research and development.","source":"@site/docs/module2/gazebo.md","sourceDirName":"module2","slug":"/module2/gazebo","permalink":"/Physical_AI_Book/docs/module2/gazebo","draft":false,"unlisted":false,"editUrl":"https://github.com/HM700/Physical_AI_Book/edit/master/frontend/docs/module2/gazebo.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Digital Twin (Gazebo & Unity)","permalink":"/Physical_AI_Book/docs/module2/intro"},"next":{"title":"Unity Simulation Environment","permalink":"/Physical_AI_Book/docs/module2/unity"}}');var r=i(4848),l=i(8453);const a={sidebar_position:2},t="Gazebo Simulation Environment",s={},c=[{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Installing Gazebo",id:"installing-gazebo",level:2},{value:"Basic Gazebo Concepts",id:"basic-gazebo-concepts",level:2},{value:"Worlds",id:"worlds",level:3},{value:"Running Gazebo",id:"running-gazebo",level:2},{value:"Integrating with ROS 2",id:"integrating-with-ros-2",level:2},{value:"Launching a Robot in Gazebo",id:"launching-a-robot-in-gazebo",level:3},{value:"Robot Modeling with URDF",id:"robot-modeling-with-urdf",level:2},{value:"Controlling Robots in Gazebo",id:"controlling-robots-in-gazebo",level:2},{value:"Adding Sensors to Robots",id:"adding-sensors-to-robots",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Exercise",id:"exercise",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"gazebo-simulation-environment",children:"Gazebo Simulation Environment"})}),"\n",(0,r.jsx)(e.p,{children:"Gazebo is a 3D dynamic simulator that supports accurate simulation of robots in complex indoor and outdoor environments. It's widely used in robotics research and development."}),"\n",(0,r.jsx)(e.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo simulates multiple robots in a 3D environment with realistic physics properties. It includes:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"High-quality graphics rendering"}),"\n",(0,r.jsx)(e.li,{children:"Accurate physics simulation"}),"\n",(0,r.jsx)(e.li,{children:"Sensors simulation (cameras, lidars, etc.)"}),"\n",(0,r.jsx)(e.li,{children:"Plugins for extending functionality"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"installing-gazebo",children:"Installing Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"For this course, we'll use Gazebo Garden:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# On Ubuntu 22.04\nsudo apt update\nsudo apt install gazebo libgazebo-dev\n\n# Or install the full desktop version\nsudo apt install gazebo libgazebo-dev gazebo-tools\n"})}),"\n",(0,r.jsx)(e.h2,{id:"basic-gazebo-concepts",children:"Basic Gazebo Concepts"}),"\n",(0,r.jsx)(e.h3,{id:"worlds",children:"Worlds"}),"\n",(0,r.jsx)(e.p,{children:"World files define the environment in which robots operate. They contain:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Terrain and environment models"}),"\n",(0,r.jsx)(e.li,{children:"Lighting conditions"}),"\n",(0,r.jsx)(e.li,{children:"Physics properties"}),"\n",(0,r.jsx)(e.li,{children:"Initial robot positions"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["Example world file (",(0,r.jsx)(e.code,{children:"my_world.sdf"}),"):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.7">\n  <world name="my_world">\n    \x3c!-- Include a ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Include a sun light --\x3e\n    <include>\n      <uri>model://sun</uri>\n    </include>\n\n    \x3c!-- Define a simple box obstacle --\x3e\n    <model name="box">\n      <pose>2 0 0.5 0 0 0</pose>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>1 0 0 1</ambient>\n            <diffuse>1 0 0 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"running-gazebo",children:"Running Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"Start Gazebo with a specific world:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"gazebo my_world.sdf\n"})}),"\n",(0,r.jsx)(e.p,{children:"Or start with an empty world:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"gazebo\n"})}),"\n",(0,r.jsx)(e.h2,{id:"integrating-with-ros-2",children:"Integrating with ROS 2"}),"\n",(0,r.jsxs)(e.p,{children:["Gazebo provides bridges to ROS 2 through the ",(0,r.jsx)(e.code,{children:"ros_gz_bridge"})," package, allowing communication between Gazebo and ROS 2 nodes."]}),"\n",(0,r.jsx)(e.h3,{id:"launching-a-robot-in-gazebo",children:"Launching a Robot in Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"Example launch file to spawn a robot:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# launch/robot_spawn.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom launch_ros.actions import Node\nfrom launch.actions import ExecuteProcess\nimport os\n\ndef generate_launch_description():\n    # Get the launch directory\n    pkg_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\n\n    return LaunchDescription([\n        # Launch Gazebo\n        ExecuteProcess(\n            cmd=['gazebo', '--verbose', '-s', 'libgazebo_ros_factory.so'],\n            output='screen'\n        ),\n\n        # Spawn robot in Gazebo\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=[\n                '-entity', 'my_robot',\n                '-file', os.path.join(pkg_dir, 'models', 'my_robot.urdf'),\n                '-x', '0', '-y', '0', '-z', '0.5'\n            ],\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,r.jsx)(e.h2,{id:"robot-modeling-with-urdf",children:"Robot Modeling with URDF"}),"\n",(0,r.jsx)(e.p,{children:"URDF (Unified Robot Description Format) describes robot models in XML format. Here's an example differential drive robot:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_diff_drive_robot">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.5 0.3 0.1"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.3 0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left wheel --\x3e\n  <link name="left_wheel">\n    <visual>\n      <geometry>\n        <cylinder length="0.05" radius="0.1"/>\n      </geometry>\n      <origin rpy="1.5708 0 0"/>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.05" radius="0.1"/>\n      </geometry>\n      <origin rpy="1.5708 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="0.2"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right wheel --\x3e\n  <link name="right_wheel">\n    <visual>\n      <geometry>\n        <cylinder length="0.05" radius="0.1"/>\n      </geometry>\n      <origin rpy="1.5708 0 0"/>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.05" radius="0.1"/>\n      </geometry>\n      <origin rpy="1.5708 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="0.2"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joints --\x3e\n  <joint name="left_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="left_wheel"/>\n    <origin xyz="-0.15 0.15 -0.05" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n  </joint>\n\n  <joint name="right_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="right_wheel"/>\n    <origin xyz="-0.15 -0.15 -0.05" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n  </joint>\n\n  \x3c!-- Differential drive controller plugin --\x3e\n  <gazebo>\n    <plugin name="diff_drive" filename="libgazebo_ros_diff_drive.so">\n      <left_joint>left_wheel_joint</left_joint>\n      <right_joint>right_wheel_joint</right_joint>\n      <wheel_separation>0.3</wheel_separation>\n      <wheel_diameter>0.2</wheel_diameter>\n      <command_topic>cmd_vel</command_topic>\n      <odometry_topic>odom</odometry_topic>\n      <odometry_frame>odom</odometry_frame>\n      <robot_base_frame>base_link</robot_base_frame>\n    </plugin>\n  </gazebo>\n</robot>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"controlling-robots-in-gazebo",children:"Controlling Robots in Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"Once your robot is in Gazebo, you can control it with ROS 2 topics:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\n\nclass GazeboController(Node):\n    def __init__(self):\n        super().__init__('gazebo_controller')\n\n        # Publisher for velocity commands\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\n\n        # Timer to send commands periodically\n        self.timer = self.create_timer(0.1, self.send_command)\n        self.i = 0\n\n    def send_command(self):\n        twist = Twist()\n\n        # Alternate between forward and rotation\n        if self.i % 20 < 10:\n            twist.linear.x = 0.5  # Move forward\n            twist.angular.z = 0.0\n        else:\n            twist.linear.x = 0.0\n            twist.angular.z = 0.5  # Rotate\n\n        self.cmd_vel_pub.publish(twist)\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = GazeboController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h2,{id:"adding-sensors-to-robots",children:"Adding Sensors to Robots"}),"\n",(0,r.jsx)(e.p,{children:"Example URDF with a camera sensor:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add to your robot URDF --\x3e\n<link name="camera_link">\n  <visual>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n    <material name="red">\n      <color rgba="1 0 0 1"/>\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <box size="0.05 0.05 0.05"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="0.01"/>\n    <inertia ixx="1e-6" ixy="0" ixz="0" iyy="1e-6" iyz="0" izz="1e-6"/>\n  </inertial>\n</link>\n\n<joint name="camera_joint" type="fixed">\n  <parent link="base_link"/>\n  <child link="camera_link"/>\n  <origin xyz="0.2 0 0.05" rpy="0 0 0"/>\n</joint>\n\n<gazebo reference="camera_link">\n  <sensor type="camera" name="camera_sensor">\n    <update_rate>30</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.3962634</horizontal_fov>\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>100</far>\n      </clip>\n    </camera>\n    <plugin name="camera_plugin" filename="libgazebo_ros_camera.so">\n      <frame_name>camera_link</frame_name>\n      <topic_name>camera/image_raw</topic_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Physics Accuracy"}),": Tune your robot's inertial properties for realistic simulation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sensor Placement"}),": Position sensors thoughtfully to match real-world placement"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Environment Complexity"}),": Start with simple environments and increase complexity gradually"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Performance"}),": Balance visual quality with simulation speed"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Validation"}),": Compare simulation results with real-world behavior when possible"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"exercise",children:"Exercise"}),"\n",(0,r.jsx)(e.p,{children:"Create a simple robot model with:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"A base and two wheels"}),"\n",(0,r.jsx)(e.li,{children:"A differential drive controller plugin"}),"\n",(0,r.jsx)(e.li,{children:"A camera sensor"}),"\n",(0,r.jsx)(e.li,{children:"A launch file to spawn the robot in Gazebo"}),"\n",(0,r.jsx)(e.li,{children:"A ROS 2 node to control the robot's movement"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"In this section, you learned:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"How to set up and use Gazebo simulation"}),"\n",(0,r.jsx)(e.li,{children:"How to create robot models in URDF format"}),"\n",(0,r.jsx)(e.li,{children:"How to integrate Gazebo with ROS 2"}),"\n",(0,r.jsx)(e.li,{children:"How to add sensors to robot models"}),"\n",(0,r.jsx)(e.li,{children:"Best practices for effective simulation"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"In the next section, we'll explore Unity integration for advanced simulation."})]})}function m(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);