"use strict";(globalThis.webpackChunkphysical_ai_book_docs=globalThis.webpackChunkphysical_ai_book_docs||[]).push([[774],{1677(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module2/integration","title":"Integrating Simulation with ROS 2","description":"In this section, we\'ll explore how to tightly integrate Gazebo simulation with your ROS 2 nodes from Module 1, creating a seamless development workflow.","source":"@site/docs/module2/integration.md","sourceDirName":"module2","slug":"/module2/integration","permalink":"/Physical_AI_Book/docs/module2/integration","draft":false,"unlisted":false,"editUrl":"https://github.com/HM700/Physical_AI_Book/edit/master/frontend/docs/module2/integration.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Unity Simulation Environment","permalink":"/Physical_AI_Book/docs/module2/unity"},"next":{"title":"Module 2 Projects","permalink":"/Physical_AI_Book/docs/module2/projects"}}');var a=s(4848),i=s(8453);const r={sidebar_position:4},t="Integrating Simulation with ROS 2",l={},c=[{value:"ROS 2 - Gazebo Bridge",id:"ros-2---gazebo-bridge",level:2},{value:"Installation",id:"installation",level:3},{value:"Running the Bridge",id:"running-the-bridge",level:3},{value:"Creating a Complete Simulation Package",id:"creating-a-complete-simulation-package",level:2},{value:"Package Structure",id:"package-structure",level:3},{value:"Launch File Example",id:"launch-file-example",level:3},{value:"Advanced Simulation Control",id:"advanced-simulation-control",level:2},{value:"Dynamic Reconfiguration",id:"dynamic-reconfiguration",level:3},{value:"Sensor Data Processing",id:"sensor-data-processing",level:2},{value:"Simulation Validation",id:"simulation-validation",level:2},{value:"Best Practices for Simulation Integration",id:"best-practices-for-simulation-integration",level:2},{value:"Exercise",id:"exercise",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"integrating-simulation-with-ros-2",children:"Integrating Simulation with ROS 2"})}),"\n",(0,a.jsx)(n.p,{children:"In this section, we'll explore how to tightly integrate Gazebo simulation with your ROS 2 nodes from Module 1, creating a seamless development workflow."}),"\n",(0,a.jsx)(n.h2,{id:"ros-2---gazebo-bridge",children:"ROS 2 - Gazebo Bridge"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"ros_gz_bridge"})," package allows bidirectional communication between ROS 2 and Gazebo. This bridge translates ROS 2 messages to Gazebo messages and vice versa."]}),"\n",(0,a.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Install the bridge package\nsudo apt install ros-humble-ros-gz-bridge\n"})}),"\n",(0,a.jsx)(n.h3,{id:"running-the-bridge",children:"Running the Bridge"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"# Run the bridge with a specific configuration\nros2 run ros_gz_bridge parameter_bridge \\\n  --ros-args -p topic_name:=/cmd_vel@geometry_msgs/msg/Twist@gz.msgs.Twist \\\n  -p topic_name2:=/odom@nav_msgs/msg/Odometry@gz.msgs.Odometry\n"})}),"\n",(0,a.jsx)(n.h2,{id:"creating-a-complete-simulation-package",children:"Creating a Complete Simulation Package"}),"\n",(0,a.jsx)(n.p,{children:"Let's create a complete ROS 2 package that integrates with Gazebo:"}),"\n",(0,a.jsx)(n.h3,{id:"package-structure",children:"Package Structure"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"robot_simulation/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 launch/\n\u2502   \u251c\u2500\u2500 robot_world.launch.py\n\u2502   \u2514\u2500\u2500 bringup_launch.py\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 my_robot/\n\u2502       \u251c\u2500\u2500 model.sdf\n\u2502       \u2514\u2500\u2500 meshes/\n\u251c\u2500\u2500 worlds/\n\u2502   \u251c\u2500\u2500 simple_room.world\n\u2502   \u2514\u2500\u2500 maze.world\n\u251c\u2500\u2500 rviz/\n\u2502   \u2514\u2500\u2500 robot_view.rviz\n\u2514\u2500\u2500 config/\n    \u2514\u2500\u2500 robot_control.yaml\n"})}),"\n",(0,a.jsx)(n.h3,{id:"launch-file-example",children:"Launch File Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# launch/robot_world.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.conditions import IfCondition\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch Arguments\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\n    world = LaunchConfiguration('world', default='simple_room.world')\n\n    # Paths\n    pkg_gazebo_ros = FindPackageShare('gazebo_ros')\n    pkg_robot_simulation = FindPackageShare('robot_simulation')\n\n    # Gazebo launch\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([pkg_gazebo_ros, 'launch', 'gazebo.launch.py'])\n        ]),\n        launch_arguments={\n            'world': PathJoinSubstitution([pkg_robot_simulation, 'worlds', world]),\n            'verbose': 'false',\n        }.items()\n    )\n\n    # Robot State Publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='screen',\n        parameters=[{'use_sim_time': use_sim_time}],\n    )\n\n    # Spawn Entity\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'my_robot',\n            '-x', '0.0',\n            '-y', '0.0',\n            '-z', '0.5'\n        ],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        DeclareLaunchArgument(\n            'world',\n            default_value='simple_room.world',\n            description='Choose one of the world files from `/robot_simulation/worlds`'\n        ),\n\n        DeclareLaunchArgument(\n            'use_sim_time',\n            default_value='true',\n            description='Use simulation (Gazebo) clock if true'\n        ),\n\n        gazebo,\n        robot_state_publisher,\n        spawn_entity,\n    ])\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-simulation-control",children:"Advanced Simulation Control"}),"\n",(0,a.jsx)(n.h3,{id:"dynamic-reconfiguration",children:"Dynamic Reconfiguration"}),"\n",(0,a.jsx)(n.p,{children:"You can dynamically change simulation parameters using ROS 2 services:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool\nfrom rcl_interfaces.msg import Parameter, ParameterType, ParameterValue\nfrom rcl_interfaces.srv import SetParameters\n\nclass SimulationController(Node):\n    def __init__(self):\n        super().__init__(\'simulation_controller\')\n\n        # Service to pause/resume simulation\n        self.pause_service = self.create_service(\n            SetBool, \'pause_simulation\', self.pause_simulation_callback\n        )\n\n        # Service to reset simulation\n        self.reset_service = self.create_service(\n            SetBool, \'reset_simulation\', self.reset_simulation_callback\n        )\n\n        # Publisher to Gazebo world control topic\n        self.world_control_pub = self.create_publisher(\n            # This would use gz.msgs.WorldControl in a real implementation\n            # For this example, we\'ll simulate with a custom message\n            String,\n            \'/world_control\',\n            10\n        )\n\n    def pause_simulation_callback(self, request, response):\n        """Pause or resume the simulation."""\n        if request.data:\n            # Send pause command to Gazebo\n            cmd_msg = String()\n            cmd_msg.data = "pause"\n            self.world_control_pub.publish(cmd_msg)\n            response.success = True\n            response.message = "Simulation paused"\n        else:\n            # Send unpause command to Gazebo\n            cmd_msg = String()\n            cmd_msg.data = "unpause"\n            self.world_control_pub.publish(cmd_msg)\n            response.success = True\n            response.message = "Simulation resumed"\n\n        return response\n\n    def reset_simulation_callback(self, request, response):\n        """Reset the simulation."""\n        if request.data:  # Reset requested\n            cmd_msg = String()\n            cmd_msg.data = "reset"\n            self.world_control_pub.publish(cmd_msg)\n            response.success = True\n            response.message = "Simulation reset"\n        else:\n            response.success = False\n            response.message = "Reset cancelled"\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = SimulationController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"sensor-data-processing",children:"Sensor Data Processing"}),"\n",(0,a.jsx)(n.p,{children:"Simulated sensors provide data that should match real sensors as closely as possible:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan, Image, CameraInfo\nfrom cv_bridge import CvBridge\nimport numpy as np\nimport cv2\n\nclass SensorProcessor(Node):\n    def __init__(self):\n        super().__init__('sensor_processor')\n\n        # Create CV bridge for image processing\n        self.cv_bridge = CvBridge()\n\n        # Subscriptions for different sensor types\n        self.laser_sub = self.create_subscription(\n            LaserScan, '/laser_scan', self.laser_callback, 10\n        )\n        self.camera_sub = self.create_subscription(\n            Image, '/camera/image_raw', self.camera_callback, 10\n        )\n        self.camera_info_sub = self.create_subscription(\n            CameraInfo, '/camera/camera_info', self.camera_info_callback, 10\n        )\n\n        # Publishers for processed data\n        self.obstacle_pub = self.create_publisher(\n            Bool, '/obstacle_detected', 10\n        )\n        self.processed_image_pub = self.create_publisher(\n            Image, '/processed_image', 10\n        )\n\n        # Store camera info\n        self.camera_info = None\n\n    def laser_callback(self, msg):\n        \"\"\"Process laser scan data to detect obstacles.\"\"\"\n        # Find minimum distance in forward arc (\xb130 degrees)\n        angle_min = msg.angle_min\n        angle_increment = msg.angle_increment\n\n        # Calculate indices for forward arc\n        forward_start_idx = int((np.radians(-30) - angle_min) / angle_increment)\n        forward_end_idx = int((np.radians(30) - angle_min) / angle_increment)\n\n        # Make sure indices are within bounds\n        forward_start_idx = max(0, forward_start_idx)\n        forward_end_idx = min(len(msg.ranges), forward_end_idx)\n\n        # Extract forward ranges\n        forward_ranges = msg.ranges[forward_start_idx:forward_end_idx]\n\n        # Filter out invalid ranges (inf, nan)\n        valid_ranges = [r for r in forward_ranges if r != float('inf') and not np.isnan(r)]\n\n        if valid_ranges:\n            min_distance = min(valid_ranges)\n\n            # Check if obstacle is closer than safety threshold\n            safety_threshold = 0.5  # meters\n            obstacle_msg = Bool()\n            obstacle_msg.data = min_distance < safety_threshold\n\n            self.obstacle_pub.publish(obstacle_msg)\n\n            self.get_logger().info(f'Closest obstacle: {min_distance:.2f}m, Obstacle: {obstacle_msg.data}')\n\n    def camera_callback(self, msg):\n        \"\"\"Process camera image.\"\"\"\n        try:\n            # Convert ROS Image message to OpenCV image\n            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n\n            # Example: Simple edge detection\n            gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\n            edges = cv2.Canny(gray, 50, 150)\n\n            # Convert back to ROS Image message\n            processed_msg = self.cv_bridge.cv2_to_imgmsg(edges, encoding='mono8')\n            processed_msg.header = msg.header  # Preserve header info\n\n            self.processed_image_pub.publish(processed_msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Error processing camera image: {str(e)}')\n\n    def camera_info_callback(self, msg):\n        \"\"\"Store camera calibration info.\"\"\"\n        self.camera_info = msg\n\ndef main(args=None):\n    rclpy.init(args=args)\n    processor = SensorProcessor()\n\n    try:\n        rclpy.spin(processor)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        processor.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"simulation-validation",children:"Simulation Validation"}),"\n",(0,a.jsx)(n.p,{children:"Validate that your simulation behaves like the real world:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom nav_msgs.msg import Odometry\nfrom geometry_msgs.msg import Twist\nimport math\n\nclass SimulationValidator(Node):\n    def __init__(self):\n        super().__init__(\'simulation_validator\')\n\n        # Subscriptions\n        self.odom_sub = self.create_subscription(\n            Odometry, \'/odom\', self.odom_callback, 10\n        )\n\n        # Publishers\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n\n        # Store previous state for validation\n        self.prev_odom = None\n        self.velocity_errors = []\n\n        # Timer for sending validation commands\n        self.timer = self.create_timer(1.0, self.send_validation_commands)\n\n    def odom_callback(self, msg):\n        """Validate odometry against expected motion."""\n        if self.prev_odom is not None:\n            # Calculate time difference\n            dt = (msg.header.stamp.sec - self.prev_odom.header.stamp.sec) + \\\n                 (msg.header.stamp.nanosec - self.prev_odom.header.stamp.nanosec) / 1e9\n\n            if dt > 0:\n                # Calculate actual velocities from odometry\n                dx = msg.pose.pose.position.x - self.prev_odom.pose.pose.position.x\n                dy = msg.pose.pose.position.y - self.prev_odom.pose.pose.position.y\n                dz = msg.pose.pose.position.z - self.prev_odom.pose.pose.position.z\n\n                actual_vx = math.sqrt(dx*dx + dy*dy) / dt\n                actual_vz = math.sqrt(dz*dz) / dt  # Simplified for example\n\n                # Compare with expected velocities (stored from commands)\n                # This would require storing the commanded velocities\n                # For this example, we\'ll just log the actual velocities\n\n                self.get_logger().info(f\'Actual velocity: vx={actual_vx:.2f}, vz={actual_vz:.2f}\')\n\n        self.prev_odom = msg\n\n    def send_validation_commands(self):\n        """Send commands to test robot motion."""\n        cmd = Twist()\n        cmd.linear.x = 0.5  # Move forward at 0.5 m/s\n        cmd.angular.z = 0.2  # Turn at 0.2 rad/s\n        self.cmd_vel_pub.publish(cmd)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = SimulationValidator()\n\n    try:\n        rclpy.spin(validator)\n    except KeyboardInterrupt:\n        # Print validation statistics\n        print(f"Velocity errors recorded: {len(validator.velocity_errors)}")\n    finally:\n        validator.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices-for-simulation-integration",children:"Best Practices for Simulation Integration"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Realistic Parameters"}),": Use realistic physical parameters for your robot models"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Sensor Noise"}),": Add appropriate noise models to simulate real sensor behavior"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Latency Simulation"}),": Account for communication delays in real systems"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Computational Load"}),": Simulate computational constraints that affect real-time performance"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Validation"}),": Regularly compare simulation results with real-world tests"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"exercise",children:"Exercise"}),"\n",(0,a.jsx)(n.p,{children:"Create a complete simulation scenario that:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Spawns a robot in a Gazebo world"}),"\n",(0,a.jsx)(n.li,{children:"Implements a simple navigation task (go to goal)"}),"\n",(0,a.jsx)(n.li,{children:"Uses sensor data for obstacle avoidance"}),"\n",(0,a.jsx)(n.li,{children:"Validates the robot's motion against expected behavior"}),"\n",(0,a.jsx)(n.li,{children:"Logs simulation metrics for analysis"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(n.p,{children:"In this section, you learned:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"How to create complete simulation packages"}),"\n",(0,a.jsx)(n.li,{children:"How to integrate ROS 2 nodes with Gazebo"}),"\n",(0,a.jsx)(n.li,{children:"How to process and validate sensor data in simulation"}),"\n",(0,a.jsx)(n.li,{children:"Best practices for realistic simulation"}),"\n",(0,a.jsx)(n.li,{children:"Techniques for simulation validation"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In the next section, we'll explore advanced simulation techniques and comparison with real hardware."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>r,x:()=>t});var o=s(6540);const a={},i=o.createContext(a);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);